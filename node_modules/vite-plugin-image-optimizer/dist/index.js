"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const fs = require("fs");
const fsp = require("fs/promises");
const pathe = require("pathe");
const ansi = require("ansi-colors");
const FILENAME_RE = /(^|[/\\])([^/\\]+?)(?=(\.[^.]+)?$)/;
function filename(path) {
  var _a;
  return (_a = path.match(FILENAME_RE)) == null ? void 0 : _a[2];
}
function isRegex(src) {
  return Object.prototype.toString.call(src) === "[object RegExp]";
}
function deepClone(src) {
  if (typeof src !== "object" || isRegex(src) || src === null)
    return src;
  const target = Array.isArray(src) ? [] : {};
  for (const key in src) {
    const value = src[key];
    target[key] = deepClone(value);
  }
  return target;
}
function merge(src, target) {
  const clone = deepClone(src);
  for (const key in target) {
    if (clone[key] === void 0) {
      clone[key] = target[key];
    }
  }
  return clone;
}
function readAllFiles(root) {
  let resultArr = [];
  try {
    if (fs.existsSync(root)) {
      const stat = fs.lstatSync(root);
      if (stat.isDirectory()) {
        const files = fs.readdirSync(root);
        files.forEach(function(file) {
          const t = readAllFiles(pathe.join(root, "/", file));
          resultArr = resultArr.concat(t);
        });
      } else {
        resultArr.push(root);
      }
    }
  } catch (error) {
    console.log(error);
  }
  return resultArr;
}
const VITE_PLUGIN_NAME = "vite-plugin-image-optimizer";
const DEFAULT_OPTIONS = {
  logStats: true,
  includePublic: true,
  exclude: void 0,
  include: void 0,
  test: /\.(jpe?g|png|gif|tiff|webp|svg|avif)$/i,
  svg: {
    multipass: true,
    plugins: [
      {
        name: "preset-default",
        params: {
          overrides: {
            cleanupNumericValues: false,
            removeViewBox: false
            // https://github.com/svg/svgo/issues/1128
          },
          cleanupIDs: {
            minify: false,
            remove: false
          },
          convertPathData: false
        }
      },
      "sortAttrs",
      {
        name: "addAttributesToSVGElement",
        params: {
          attributes: [{ xmlns: "http://www.w3.org/2000/svg" }]
        }
      }
    ]
  },
  png: {
    // https://sharp.pixelplumbing.com/api-output#png
    quality: 100
  },
  jpeg: {
    // https://sharp.pixelplumbing.com/api-output#jpeg
    quality: 100
  },
  jpg: {
    // https://sharp.pixelplumbing.com/api-output#jpeg
    quality: 100
  },
  tiff: {
    // https://sharp.pixelplumbing.com/api-output#tiff
    quality: 100
  },
  // gif does not support lossless compression
  // https://sharp.pixelplumbing.com/api-output#gif
  gif: {},
  webp: {
    // https://sharp.pixelplumbing.com/api-output#webp
    lossless: true
  },
  avif: {
    // https://sharp.pixelplumbing.com/api-output#avif
    lossless: true
  }
};
function ViteImageOptimizer(optionsParam = {}) {
  const options = merge(optionsParam, DEFAULT_OPTIONS);
  let outputPath;
  let publicDir;
  let rootConfig;
  const sizesMap = /* @__PURE__ */ new Map();
  const mtimeCache = /* @__PURE__ */ new Map();
  const errorsMap = /* @__PURE__ */ new Map();
  const applySVGO = async (filePath, buffer) => {
    const optimize = (await import("svgo")).optimize;
    return Buffer.from(
      optimize(buffer.toString(), {
        path: filePath,
        ...options.svg
      }).data
    );
  };
  const applySharp = async (filePath, buffer) => {
    const sharp = (await import("sharp")).default;
    const extName = pathe.extname(filePath).replace(".", "");
    return await sharp(buffer, { animated: extName === "gif" }).toFormat(extName, options[extName.toLowerCase()]).toBuffer();
  };
  const processFile = async (filePath, buffer) => {
    try {
      const engine = /\.svg$/.test(filePath) ? applySVGO : applySharp;
      const newBuffer = await engine(filePath, buffer);
      const newSize = newBuffer.byteLength;
      const oldSize = buffer.byteLength;
      const skipWrite = newSize >= oldSize;
      sizesMap.set(filePath, {
        size: newSize / 1024,
        oldSize: oldSize / 1024,
        ratio: Math.floor(100 * (newSize / oldSize - 1)),
        skipWrite
      });
      return { content: newBuffer, skipWrite };
    } catch (error) {
      errorsMap.set(filePath, error.message);
      return {};
    }
  };
  return {
    name: VITE_PLUGIN_NAME,
    enforce: "post",
    apply: "build",
    configResolved(c) {
      rootConfig = c;
      outputPath = c.build.outDir;
      if (typeof c.publicDir === "string") {
        publicDir = c.publicDir.replace(/\\/g, "/");
      }
    },
    generateBundle: async (_, bundler) => {
      const files = [];
      const allFiles = Object.keys(bundler);
      if (options.include) {
        allFiles.forEach((filePath) => {
          const fileName = bundler[filePath].name;
          if (isIncludedFile(fileName, options.include)) {
            files.push(filePath);
          }
        });
      } else {
        allFiles.forEach((filePath) => {
          if (options.test.test(filePath)) {
            const fileName = bundler[filePath].name;
            if (!isExcludedFile(fileName, options.exclude)) {
              files.push(filePath);
            }
          }
        });
      }
      if (files.length > 0) {
        const handles = files.map(async (filePath) => {
          const source = bundler[filePath].source;
          const { content, skipWrite } = await processFile(filePath, source);
          if ((content == null ? void 0 : content.length) > 0 && !skipWrite) {
            bundler[filePath].source = content;
          }
        });
        await Promise.all(handles);
      }
    },
    async closeBundle() {
      if (publicDir && options.includePublic) {
        const files = [];
        const allFiles = readAllFiles(publicDir);
        if (options.include) {
          allFiles.forEach((filePath) => {
            const fileName = filename(filePath) + pathe.extname(filePath);
            if (isIncludedFile(fileName, options.include)) {
              files.push(filePath);
            }
          });
        } else {
          allFiles.forEach((filePath) => {
            if (options.test.test(filePath)) {
              const fileName = filename(filePath) + pathe.extname(filePath);
              if (!isExcludedFile(fileName, options.exclude)) {
                files.push(filePath);
              }
            }
          });
        }
        if (files.length > 0) {
          const handles = files.map(async (publicFilePath) => {
            const filePath = publicFilePath.replace(publicDir + pathe.sep, "");
            const fullFilePath = pathe.join(outputPath, filePath);
            if (fs.existsSync(fullFilePath) === false) {
              return;
            }
            const { mtimeMs } = await fsp.stat(fullFilePath);
            if (mtimeMs <= (mtimeCache.get(filePath) || 0)) {
              return;
            }
            const buffer = await fsp.readFile(fullFilePath);
            const { content, skipWrite } = await processFile(filePath, buffer);
            if ((content == null ? void 0 : content.length) > 0 && !skipWrite) {
              await fsp.writeFile(fullFilePath, content);
              mtimeCache.set(filePath, Date.now());
            }
          });
          await Promise.all(handles);
        }
      }
      if (sizesMap.size > 0 && options.logStats) {
        logOptimizationStats(rootConfig, sizesMap);
      }
      if (errorsMap.size > 0) {
        logErrors(rootConfig, errorsMap);
      }
    }
  };
}
function isIncludedFile(fileName, include) {
  return checkFileMatch(fileName, include);
}
function isExcludedFile(fileName, exclude) {
  return checkFileMatch(fileName, exclude);
}
function checkFileMatch(fileName, matcher) {
  const isString = Object.prototype.toString.call(matcher) === "[object String]";
  const isArray = Array.isArray(matcher);
  if (isString) {
    return fileName === matcher;
  }
  if (isRegex(matcher)) {
    return matcher.test(fileName);
  }
  if (isArray) {
    return matcher.includes(fileName);
  }
  return false;
}
function logErrors(rootConfig, errorsMap) {
  rootConfig.logger.info(`
ðŸš¨ ${ansi.red("[vite-plugin-image-optimizer]")} - errors during optimization for: `);
  const keyLengths = Array.from(errorsMap.keys(), (name) => name.length);
  const maxKeyLength = Math.max(...keyLengths);
  errorsMap.forEach((message, name) => {
    rootConfig.logger.error(
      `${ansi.dim(pathe.basename(rootConfig.build.outDir))}/${ansi.blueBright(name)}${" ".repeat(2 + maxKeyLength - name.length)} ${ansi.red(
        message
      )}`
    );
  });
  rootConfig.logger.info("\n");
}
function logOptimizationStats(rootConfig, sizesMap) {
  rootConfig.logger.info(`
âœ¨ ${ansi.cyan("[vite-plugin-image-optimizer]")} - optimized image resources successfully: `);
  const keyLengths = Array.from(sizesMap.keys(), (name) => name.length);
  const valueLengths = Array.from(sizesMap.values(), (value) => `${Math.floor(100 * value.ratio)}`.length);
  const maxKeyLength = Math.max(...keyLengths);
  const valueKeyLength = Math.max(...valueLengths);
  sizesMap.forEach((value, name) => {
    const { size, oldSize, ratio, skipWrite } = value;
    const percentChange = ratio > 0 ? ansi.red(`+${ratio}%`) : ratio <= 0 ? ansi.green(`${ratio}%`) : "";
    const sizeText = skipWrite ? `${ansi.yellow.bold("skipped")} ${ansi.dim(`original: ${oldSize.toFixed(2)}kb <= optimized: ${size.toFixed(2)}kb`)}` : ansi.dim(`${oldSize.toFixed(2)}kb -> ${size.toFixed(2)}kb`);
    rootConfig.logger.info(
      ansi.dim(pathe.basename(rootConfig.build.outDir)) + "/" + ansi.blueBright(name) + " ".repeat(2 + maxKeyLength - name.length) + ansi.gray(`${percentChange} ${" ".repeat(valueKeyLength - `${ratio}`.length)}`) + " " + sizeText
    );
  });
  rootConfig.logger.info("\n");
}
exports.ViteImageOptimizer = ViteImageOptimizer;
